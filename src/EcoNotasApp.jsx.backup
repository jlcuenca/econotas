import React, { useState, useRef, useEffect, useCallback } from 'react';
import { Mic, Square, Play, Pause, Save, PenTool, Clock, RotateCcw, Download, Upload } from 'lucide-react';

const EcoNotasApp = () => {
    // --- ESTADOS DEL SISTEMA ---
    const [mode, setMode] = useState('IDLE'); // IDLE, RECORDING, PLAYING, PAUSED
    const [duration, setDuration] = useState(0); // Duración en segundos
    const [currentTime, setCurrentTime] = useState(0); // Tiempo actual de reproducción/grabación
    const [strokes, setStrokes] = useState([]); // Almacén de trazos vectoriales
    const [audioBlob, setAudioBlob] = useState(null); // El archivo de audio crudo
    const [audioUrl, setAudioUrl] = useState(null); // URL para reproducir el audio
    const [penColor, setPenColor] = useState('#e2e8f0'); // Color de tinta (claro por default tema oscuro)

    // --- REFERENCIAS (MEMORIA MUTABLE) ---
    const canvasRef = useRef(null);
    const mediaRecorderRef = useRef(null);
    const audioChunksRef = useRef([]);
    // Inicialización perezosa para evitar errores en SSR, aunque aquí es cliente
    const audioPlayerRef = useRef(typeof Audio !== "undefined" ? new Audio() : null);
    const startTimeRef = useRef(0);
    const rafRef = useRef(null); // Request Animation Frame ID
    const currentStrokeRef = useRef(null); // Trazo que se está dibujando actualmente

    // --- CONFIGURACIÓN INICIAL ---
    useEffect(() => {
        // Configurar Canvas para alta resolución (Retina displays)
        const canvas = canvasRef.current;
        if (!canvas) return;

        const ctx = canvas.getContext('2d');

        const resizeCanvas = () => {
            const parent = canvas.parentElement;
            if (parent) {
                canvas.width = parent.clientWidth;
                canvas.height = parent.clientHeight;
            }

            // Estilos de dibujo base
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            redrawCanvas(0, true); // Redibujar todo estático si cambia tamaño
        };

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();
        const handlePointerDown = (e) => {
            if (mode !== 'RECORDING') return;

            const { offsetX, offsetY, pressure } = getCoordinates(e);
            const timeOffset = Date.now() - startTimeRef.current;

            currentStrokeRef.current = {
                color: penColor,
                startTime: timeOffset,
                points: [{ x: offsetX, y: offsetY, p: pressure || 0.5, t: timeOffset }]
            };

            // Dibujado instantáneo (feedback visual)
            const ctx = canvasRef.current.getContext('2d');
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY);
            // Ajustar grosor por presión
            ctx.lineWidth = (pressure || 0.5) * 8;
            ctx.strokeStyle = penColor;
        };

        const handlePointerMove = (e) => {
            if (mode !== 'RECORDING' || !currentStrokeRef.current) return;
            e.preventDefault(); // Evitar scroll en touch

            const { offsetX, offsetY, pressure } = getCoordinates(e);
            const timeOffset = Date.now() - startTimeRef.current;

            // Guardar datos
            currentStrokeRef.current.points.push({
                x: offsetX,
                y: offsetY,
                p: pressure || 0.5,
                t: timeOffset
            });

            // Dibujar línea
            const ctx = canvasRef.current.getContext('2d');
            const points = currentStrokeRef.current.points;
            // const lastPoint = points[points.length - 2]; // No usado en esta implementación simple

            ctx.lineWidth = (pressure || 0.5) * 8;
            ctx.lineCap = 'round';
            ctx.lineTo(offsetX, offsetY);
            ctx.stroke();

            // Hack para suavizar: comenzar nuevo path en cada punto para variar grosor
            ctx.beginPath();
            ctx.moveTo(offsetX, offsetY);
        };

        const handlePointerUp = () => {
            if (mode !== 'RECORDING' || !currentStrokeRef.current) return;

            // CORRECCIÓN CRÍTICA:
            // Capturamos el objeto stroke en una variable local ANTES de limpiar la referencia.
            // Esto evita que la actualización asíncrona de React acceda a un valor null.
            const finishedStroke = currentStrokeRef.current;

            // Finalizar trazo y guardar en estado React
            setStrokes(prev => [...prev, finishedStroke]);

            // Resetear referencia
            currentStrokeRef.current = null;
        };

        const getCoordinates = (e) => {
            // PointerEvent nativo tiene offsetX/Y y pressure
            // Ajuste simple para coordenadas relativas
            const rect = canvasRef.current.getBoundingClientRect();
            return {
                offsetX: e.clientX - rect.left,
                offsetY: e.clientY - rect.top,
                pressure: e.pressure
            };
        };

        // --- MOTOR DE REPRODUCCIÓN (CORE DE ECONOTAS) ---

        const togglePlayback = () => {
            if (!audioUrl || !audioPlayerRef.current) return;

            if (mode === 'PLAYING') {
                audioPlayerRef.current.pause();
                setMode('PAUSED');
                cancelAnimationFrame(rafRef.current);
            } else {
                audioPlayerRef.current.play();
                setMode('PLAYING');
                animate();
            }
        };

        const animate = () => {
            if (!audioPlayerRef.current || audioPlayerRef.current.paused || audioPlayerRef.current.ended) {
                if (audioPlayerRef.current && audioPlayerRef.current.ended) setMode('IDLE');
                return;
            }

            const playHead = audioPlayerRef.current.currentTime * 1000; // Segundos a ms
            setCurrentTime(playHead);

            // La magia: redibujar canvas basado en el tiempo
            redrawCanvas(playHead, false);

            rafRef.current = requestAnimationFrame(animate);
        };

        // Esta función dibuja el estado del mundo en el tiempo 't'
        const redrawCanvas = (targetTimeMs, forceAll = false) => {
            const canvas = canvasRef.current;
            if (!canvas) return;
            const ctx = canvas.getContext('2d');

            // 1. Limpiar
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // 2. Iterar sobre todos los trazos
            strokes.forEach(stroke => {
                // SAFETY CHECK: Evitar crash si entra un trazo nulo
                if (!stroke) return;

                // Si el trazo no ha empezado todavía en este punto del audio, saltarlo
                if (!forceAll && stroke.startTime > targetTimeMs) return;

                ctx.beginPath();
                // Aquí ocurría el error si stroke era null
                ctx.strokeStyle = stroke.color;

                let hasStarted = false;

                // 3. Iterar sobre puntos del trazo
                for (let i = 0; i < stroke.points.length; i++) {
                    const point = stroke.points[i];

                    // Si estamos renderizando animación y este punto es del futuro, paramos el trazo aquí
                    if (!forceAll && point.t > targetTimeMs) break;

                    // Lógica de dibujo
                    ctx.lineWidth = point.p * 8; // Grosor dinámico

                    if (!hasStarted) {
                        ctx.moveTo(point.x, point.y);
                        hasStarted = true;
                    } else {
                        ctx.lineTo(point.x, point.y);
                    }
                }
                if (hasStarted) ctx.stroke();
            });
        };

        // Seek bar manual
        const handleSeek = (e) => {
            if (!audioPlayerRef.current) return;
            const seekTime = Number(e.target.value);
            audioPlayerRef.current.currentTime = seekTime;
            setCurrentTime(seekTime * 1000);
            redrawCanvas(seekTime * 1000, false);
        };

        // --- UTILS ---
        const formatTime = (ms) => {
            const totalSeconds = Math.floor(ms / 1000);
            const mins = Math.floor(totalSeconds / 60);
            const secs = totalSeconds % 60;
            return `${mins}:${secs.toString().padStart(2, '0')}`;
        };

        const downloadSession = () => {
            const data = {
                date: new Date().toISOString(),
                duration: duration,
                strokes: strokes
            };
            const jsonString = JSON.stringify(data);
            const blob = new Blob([jsonString], { type: "application/json" });
            const url = URL.createObjectURL(blob);

            // Descargar JSON
            const a = document.createElement('a');
            a.href = url;
            a.download = "sesion-econotas.json";
            a.click();

            // Nota: En una app real, aquí también descargarías o subirías el audioBlob
            if (audioUrl) {
                const a2 = document.createElement('a');
                a2.href = audioUrl;
                a2.download = "sesion-econotas.webm";
                a2.click();
            }
        };

        return (
            <div className="flex flex-col h-screen bg-slate-900 text-slate-100 font-sans overflow-hidden">
                {/* TOOLBAR SUPERIOR */}
                <div className="h-16 border-b border-slate-700 bg-slate-800 flex items-center justify-between px-6 shadow-lg z-10">
                    <div className="flex items-center gap-2">
                        <div className="w-8 h-8 bg-indigo-500 rounded-lg flex items-center justify-center transform rotate-12">
                            <PenTool className="w-5 h-5 text-white" />
                        </div>
                        <h1 className="text-xl font-bold tracking-tight">EcoNotas<span className="text-indigo-400">Notes</span></h1>
                    </div>

                    {/* Display de Tiempo */}
                    <div className="flex items-center gap-4 bg-slate-900 py-1 px-4 rounded-full border border-slate-700">
                        <Clock className={`w-4 h-4 ${mode === 'RECORDING' ? 'text-red-500 animate-pulse' : 'text-slate-400'}`} />
                        <span className="font-mono text-lg">{formatTime(mode === 'RECORDING' || mode === 'IDLE' && !audioUrl ? duration * 1000 : currentTime)}</span>
                    </div>

                    {/* Acciones */}
                    <div className="flex gap-2">
                        {audioUrl && (
                            <button onClick={downloadSession} className="p-2 hover:bg-slate-700 rounded-full transition-colors" title="Guardar Sesión">
                                <Download className="w-5 h-5 text-slate-400" />
                            </button>
                        )}
                    </div>
                </div>

                {/* ÁREA PRINCIPAL */}
                <div className="flex-1 relative bg-slate-900 cursor-crosshair touch-none">

                    {/* Grid de Fondo (Efecto Papel Oscuro) */}
                    <div className="absolute inset-0 pointer-events-none opacity-20"
                        style={{
                            backgroundImage: 'radial-gradient(#6366f1 1px, transparent 1px)',
                            backgroundSize: '24px 24px'
                        }}>
                    </div>

                    {/* Canvas Layer */}
                    <canvas
                        ref={canvasRef}
                        className="w-full h-full block touch-none"
                        onPointerDown={handlePointerDown}
                        onPointerMove={handlePointerMove}
                        onPointerUp={handlePointerUp}
                        onPointerLeave={handlePointerUp}
                    />

                    {/* Overlay de bienvenida */}
                    {mode === 'IDLE' && strokes.length === 0 && (
                        <div className="absolute inset-0 flex items-center justify-center pointer-events-none">
                            <div className="text-center text-slate-500">
                                <Mic className="w-12 h-12 mx-auto mb-2 opacity-50" />
                                <p className="text-lg">Presiona Grabar para comenzar</p>
                                <p className="text-sm opacity-60">Usa tu stylus o mouse</p>
                            </div>
                        </div>
                    )}
                </div>

                {/* BARRA DE CONTROL INFERIOR */}
                <div className="h-20 bg-slate-800 border-t border-slate-700 p-4 flex flex-col justify-center">

                    {/* Seek Bar (Solo si hay audio) */}
                    {audioUrl && audioPlayerRef.current && (
                        <input
                            type="range"
                            min="0"
                            max={audioPlayerRef.current.duration || duration}
                            value={currentTime / 1000}
                            onChange={handleSeek}
                            className="w-full h-1 bg-slate-600 rounded-lg appearance-none cursor-pointer mb-4 accent-indigo-500"
                        />
                    )}

                    <div className="flex items-center justify-center gap-6">

                        {mode === 'IDLE' || mode === 'PAUSED' ? (
                            !audioUrl ? (
                                <button
                                    onClick={startRecording}
                                    className="flex items-center gap-2 px-8 py-2 bg-red-600 hover:bg-red-700 text-white rounded-full font-bold transition-all shadow-lg shadow-red-900/20 active:scale-95"
                                >
                                    <Mic className="w-5 h-5" /> GRABAR
                                </button>
                            ) : (
                                <div className="flex gap-4">
                                    <button
                                        onClick={togglePlayback}
                                        className="flex items-center gap-2 px-8 py-2 bg-indigo-600 hover:bg-indigo-700 text-white rounded-full font-bold transition-all shadow-lg shadow-indigo-900/20"
                                    >
                                        <Play className="w-5 h-5 fill-current" /> REPRODUCIR NOTAS
                                    </button>
                                    <button
                                        onClick={() => {
                                            setAudioUrl(null);
                                            setStrokes([]);
                                            setDuration(0);
                                            if (canvasRef.current) {
                                                const ctx = canvasRef.current.getContext('2d');
                                                ctx.clearRect(0, 0, canvasRef.current.width, canvasRef.current.height);
                                            }
                                        }}
                                        className="p-2 bg-slate-700 hover:bg-slate-600 rounded-full text-slate-300"
                                    >
                                        <RotateCcw className="w-5 h-5" />
                                    </button>
                                </div>
                            )
                        ) : (
                            mode === 'RECORDING' ? (
                                <button
                                    onClick={stopRecording}
                                    className="flex items-center gap-2 px-8 py-2 bg-slate-200 text-slate-900 hover:bg-white rounded-full font-bold transition-all animate-pulse"
                                >
                                    <Square className="w-5 h-5 fill-current" /> DETENER
                                </button>
                            ) : (
                                <button
                                    onClick={togglePlayback}
                                    className="flex items-center gap-2 px-8 py-2 bg-yellow-500 text-black hover:bg-yellow-400 rounded-full font-bold transition-all"
                                >
                                    <Pause className="w-5 h-5 fill-current" /> PAUSA
                                </button>
                            )
                        )}
                    </div>
                </div>
            </div>
        );
    };

    export default EcoNotasApp;